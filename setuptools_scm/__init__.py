from __future__ import print_function
"""
:copyright: 2010-2015 by Ronny Pfannschmidt
:license: MIT
"""
import os
import sys
import time
from pkg_resources import iter_entry_points


from .utils import do, trace


def version_from_cachefile(root, cache_file=None):
    # XXX: for now we ignore root
    if not cache_file or not os.path.exists(cache_file):
        return
    # replaces 'with open()' from py2.6
    fd = open(cache_file)
    fd.readline()  # remove the comment
    version = None
    try:
        line = fd.readline()
        version_string = line.split(' = ')[1].strip()
        version = version_string[1:-1]
    except:  # any error means invalid cachefile
        pass
    fd.close()
    return version


def write_cache_file(path, version):
    fd = open(path, 'w')
    try:
        fd.write('# this file is autogenerated by setuptools_scm + setup.py\n')
        fd.write('version = "%s"\n' % version)
    finally:
        fd.close()


def version_from_scm(root):
    ep = find_matching_entrypoint(root, 'setuptools_scm.parse_scm')
    if ep:
        return ep.load()(root)


def guess_next_tag(tag):
    prefix, tail = tag.rsplit('.', 1)
    if tail.isdigit():
        return '%s.%s.dev' % (prefix, int(tail) + 1)
    else:
        assert tail == 'dev', 'broken version data'
        return tag


def format_version(version, guess_next=True):
    trace(version)
    exact = version['distance'] is None
    dirty = version['dirty']
    local_part = ''

    if version['node']:
        local_part += '+n' + version['node']
        if dirty:
            local_part += time.strftime('.d%Y%m%d')
    elif dirty:
        local_part += time.strftime('+d%Y%m%d')

    # change on top of tag
    if dirty and exact:
        version['distance'] = 0
        exact = False

    # we are clean
    if exact:
        return version['tag']

    if guess_next:
        start = guess_next_tag(version['tag'])
    else:
        start = version['tag'] + '.post'
    assert version['distance'] is not None
    return start + str(version['distance']) + local_part


def _extract_version(root, cache_file, guess_next):
    version = None
    version = version_from_scm(root)
    if not version and cache_file:
        version = version_from_cachefile(root, cache_file)
    if version:
        if isinstance(version, dict):
            return format_version(version, guess_next)
        else:
            return version


def get_version(cache_file=None, root='.', guess_next=True):
    root = os.path.abspath(root)
    trace('root', repr(root))
    if cache_file is not None:
        cache_file = os.path.join(root, cache_file)
        trace('cache_file', repr(cache_file))

    version = _extract_version(root, cache_file, guess_next)

    if cache_file and version:
        write_cache_file(cache_file, version)
    return version


def _ovalue(obj, name, default):
    if isinstance(obj, dict):
        return obj.get(name, default)
    else:
        return default


def setuptools_version_keyword(dist, keyword, value):
    if value:
        dist.metadata.version = get_version(
            cache_file=_ovalue(value, 'cache_file', None),
            guess_next=_ovalue(value, 'guess_next', True),
        )


def find_matching_entrypoint(path, entrypoint):
    trace('looking for ep', entrypoint, path)
    for ep in iter_entry_points(entrypoint):
        if os.path.exists(os.path.join(path, ep.name)):
            if os.path.isabs(ep.name):
                trace('ignoring bad ep', ep)
            trace('found ep', ep)
            return ep


def find_files(path='.'):
    if not path:
        path = '.'
    abs = os.path.abspath(path)
    ep = find_matching_entrypoint(abs, 'setuptools_scm.files_command')
    if ep:
        command = ep.load()
        if isinstance(command, str):
            return do(ep.load(), path).splitlines()
        else:
            return command(path)
    else:
        return []

if __name__ == '__main__':
    print('Guessed Version', get_version())
    if 'ls' in sys.argv:
        for fname in find_files('.'):
            print(fname)
